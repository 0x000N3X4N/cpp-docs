---
description: "Learn more about: Warning C26441 NO_UNNAMED_GUARDS"
title: Warning C26441
ms.date: 11/15/2017
f1_keywords: ["C26441", "NO_UNNAMED_GUARDS"]
helpviewer_keywords: ["C26441"]
---
# Warning C26441

> Guard objects must be named (cp.44)

**C++ Core Guidelines**:
[CP.44](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#cp44-remember-to-name-your-lock_guards-and-unique_locks): Remember to name your lock_guards and unique_locks

## Remarks

The standard library provides locks to help control concurrent access to resources during their lifetime. Attempting to declare a lock object without a name, creates a temporary object that is immediately destructed rather than living to the end of the enclosing scope. So, failing to assign a lock object to a variable is a mistake that effectively disables the locking mechanism (because temporary variables are transient). This rule tries to catch simple cases of such unintended behavior.

This diagnostic will only fire for the standard lock types  `std::scoped_lock`, `std::unique_lock`, and `std::lock_guard`. Other unnamed RAII types are covered by [C26444](c26444.md).

Only simple calls to constructors are analyzed. More complex initializer expressions may lead to inaccurate results, but it's an unusual scenario. Locks passed as arguments to function calls or returned as results of function calls are ignored. To provide similar protection for types returned by a function call, annotate with `[[nodiscard]]`. Locks created as temporaries but assigned to named references to extend their lifetime are ignored.

Code analysis name: `NO_UNNAMED_GUARDS`

## Example

This example is missing the name of the scoped lock.

```cpp
void print_diagnostic(std::string_view text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ };
        write_line(stream, text);
    }
}
```

To fix the error, we give a name to the lock, thus extending its lifetime.

```cpp
void print_diagnostic(std::string_view text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
    }
}
```

## See also

[C26444](C26444.md)
<!-- currently undocumented C4858 -->