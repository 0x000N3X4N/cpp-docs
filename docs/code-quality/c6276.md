---
description: "Learn more about: C6276"
title: C6276
ms.date: 11/04/2016
ms.topic: reference
f1_keywords: ["C6276"]
helpviewer_keywords: ["C6276"]
ms.assetid: 88f288da-da81-4d32-ab0f-be9d01a2606a
---
# C6276

**Warning C2676: CHAR to WCHAR cast(CHAR_TO_WCHAR_CAST)**\
Example output:
> Cast between semantically different string types: char* to wchar_t\*. Use of invalid string can lead to undefined behavior.

## Description

This warning indicates a potentially incorrect cast from an ANSI string (`char_t*`) to a UNICODE string (`wchar_t *`). Because UNICODE strings have a character size of 2 bytes, this cast might yield strings that are not correctly terminated. Using such strings with the wcs* library of functions could cause buffer overruns and access violations.

## Example

The following code generates this warning. This issue stems from the improper casting of the character 'a' (1 byte) to a Unicode character (2 bytes):

```cpp
#include <windows.h>
VOID f()
{
   WCHAR szBuffer[8];
   LPWSTR pSrc;
   pSrc = (LPWSTR)"a";
   wcscpy(szBuffer, pSrc);
}
```

The following code corrects this warning by appending the letter L to represent the ASCII character as a wide character:

```cpp
#include <windows.h>

VOID f()
{
   WCHAR szBuffer[8];
   LPWSTR pSrc;
   pSrc = L"a";
   wcscpy(szBuffer, pSrc);
}
```

For an additional layer of security, the following code uses the safe string manipulation function `wcscpy_s` to correct this warning. This limits the copy to 8 bytes, the size of the buffer being copied to:

```cpp
#include <windows.h>

VOID f()
{
   WCHAR szBuffer[8];
   LPWSTR pSrc;
   pSrc = L"a";
   wcscpy_s(szBuffer,8,pSrc);
}
```
