---
description: "Learn more about: Warning C6101"
title: Warning C6101
ms.date: 08/17/2022
f1_keywords: ["C6101", "RETURN_UNINIT_VAR", "__WARNING_RETURN_UNINIT_VAR"]
helpviewer_keywords: ["C6101"]
---
# Warning C6101

> Returning uninitialized memory '*parameter-name*'.

A successful path through the function does not set the `_Out_` annotated parameter.

## Remarks

The purpose of this warning is to avoid the use of uninitialized values by callers of the function. All parameters that are annotated with `_Out_` are assumed to be uninitialized before the function call and are expected to be initialized by by it. If the function returns a value indicating it had an error or was not successful then this warning is not emitted. To fix this issue make sure the `_Out_` parameter is initialized under all successful return paths. The error message will contain the line numbers of an example path that does not initialize the parameter.

If the initialization behavior is by design, then this is likely a result of incorrect or missing SAL annotations. These cases can typically be resolved by either changing `_Out_` to a more appropriate annotation, or by using the `_Success_()` annotation to help define the success/error states of the function. Having correct annotations on the function is important for the static analysis tools when analyzing the call sites of the function.

### Fixing by changing Parameter annotations

If the parameter is expected to already be in an initialized state and the function conditionally modifies it, then the `_Inout_` annotation may be more appropriate. Another option is to use lower level annotations such as `_Pre_null_`/`_Pre_satisfies_()`/`_Post_satisfies_()` which provide additional flexibility and control over the expected state of the parameter. For more information on parameter annotations see [Annotating function parameters and return values](./annotating-function-parameters-and-return-values.md).

### Fixing by defining successful return paths

This diagnostic is only emitted when the `_Out_` parameter is not initialized in the success paths of the function. If there is no `_Success_` annotation and the return type for the function is not annotated, then all return paths are considered successful. For more information on `_Success_` and other similar annotations see [Success/Failure annotations](./annotating-function-behavior.md#successfailure-annotations).

Code analysis name: `RETURN_UNINIT_VAR`

## Example

The following code generates this warning. Because the function returns void, all paths are considered successful. In this case, the correct fix would probably be to adjust the logic of the `if` statement, but in real world code it is typically not as straightforward and depends on the intended behavior of the function.

```cpp
#include <sal.h>
void AlwaysInit(_Out_ int* output, int input) // : warning C6101: Returning uninitialized memory '*p'.: Lines: 2, 4, 9, 14, 2
{
  if( input > 0 )
  {
    *output = input;
    return;
  }
  else if( input < 0 )
  {
    *output = 0;
    return;
  }
  return; // Oops, input was 0
}
```

To make the solution more interesting we assume that it is not valid to initialize `output` when `input` is `0`. One approach is to modify the function return value to a different type such as `bool` and add a `_Success_` annotation to define the successful return paths.

```cpp
_Success_(return == true)
bool InitNotZero(_Out_ int* output, int input)
{
  if( input > 0 )
  {
    *output = input;
    return true;
  }
  else if( input < 0 )
  {
    *output = 0;
    return true;
  }
  return false;
}
```

If this is a common pattern in the codebase, the annotation can be added to the return type. This is what error codes like HRESULT from the Windows SDK do to give the behavior of the `_Success_` annotation without needing to adding it to each function.  If you already use an annotated type as a return type and want to override the behavior, then it can be done by adding the annotation to the function like the previous example.

```cpp
using SuccessWhenTrue = _Success_(return == true) bool;

SuccessWhenTrue InitNotZero(_Out_ int* output, int input)
{
  // ...
```

## See also

[Rule sets for C++ code](./using-rule-sets-to-specify-the-cpp-rules-to-run.md)\
[Using SAL Annotations to Reduce C/C++ Code Defects](./using-sal-annotations-to-reduce-c-cpp-code-defects.md)
