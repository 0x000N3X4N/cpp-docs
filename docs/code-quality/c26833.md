---
title: Warning C26833
description: "Describes the Microsoft C/C++ code analysis warning C26833, its causes, and how to address it."
ms.date: 03/06/2023
f1_keywords: ["C26833", "ALLOCATION_POTENTIAL_OVERFLOW_BEFORE_CHECK"]
helpviewer_keywords: ["C26833"]
---
# Warning C26833

> Allocation size might be the result of a numerical overflow before the bound check

## Remarks

Checks for an allocation whose size may be the result of a numerical overflow. This check is targeted to find the following code pattern:

```cpp
void* SmallAlloc(int);

void foo(unsigned i, unsigned j)
{
    unsigned size = i + j;

    if (size > 50)
        return;

    int* p = (int*)SmallAlloc(size + 5); // Warning: C26833
    p[j] = 5;
}
```

The code example above has a check `size > 50`. Unfortunately, this check is too late. In case `i + j` overflows, it produces a small value that passes the check. So, `SmallAlloc` allocates a buffer smaller than expected. Future accesses of the buffer like `p[i]` are out of bounds. These code patterns can result in remote code execution vulnerabilities.
Common allocation functions like `new`, `malloc`, and `VirtalAlloc` are recognized. The check also tries to recognize custom allocator functions by case insensitive search for the `alloc` substring in the function name.

Our analysis engine's numerical solver have some limitations reasoning about numerical overflows. As a result, this check is using some heuristics and sometimes fails to recognize that certain checks can prevent overflows.
Usually, checking for a reasonable bound on the allocation should work. 

This warning is available in Visual Studio 2022 version 17.7 and later versions.
## Example

To fix the previous code example, make sure `i+j` cannot overflow. For example:

```cpp
void* SmallAlloc(int);

void foo(unsigned i, unsigned j)
{
    if (i > 100 || j > 100)
        return;

    unsigned size = i + j;

    if (size > 50)
        return;

    int* p = (int*)SmallAlloc(size + 5);
    p[j] = 5;
}
```

## See also

[C26831](c26831.md)\
[C26832](c26832.md)