---
title: Warning C26831
description: "Describes the Microsoft C/C++ code analysis warning C26831, its causes, and how to address it."
ms.date: 03/06/2023
f1_keywords: ["C26831", "ALLOCATION_POTENTIAL_OVERFLOW"]
helpviewer_keywords: ["C26831"]
---
# Warning C26831

> Allocation size might be the result of a numerical overflow

## Remarks

Checks for allocations that have potentially overflown values as their sizes. This check is targeted to find the following code pattern:

```cpp
void *SmallAlloc(int);

void foo(int i, int j)
{
    int* p = (int*)SmallAlloc(i + j); // Warning: C26831
    p[i] = 5;
}
```

In case `i+j` overflows, `SmallAlloc` returns a buffer that is smaller than expected. As a result, future accesses to the buffer like `p[i]` are out of bounds. These code patterns can result in remote code execution vulnerabilities.

Common allocation functions like `new`, `malloc`, and `VirtalAlloc` are recognized. The check also tries to recognize custom allocator functions by case insensitive search for the `alloc` substring in the function name.

Our analysis engine's numerical solver have some limitations reasoning about numerical overflows. As a result, this check is using some heuristics and sometimes fails to recognize that certain checks can prevent overflows.
Usually, checking for a reasonable bound on the allocation should work. 

This warning is available in Visual Studio 2022 version 17.7 and later versions.

## Example

To fix the code example above, make sure `i+j` can't overflow. For example:

```cpp
void *SmallAlloc(int);

void foo(int i, int j)
{
    if (i < 0 || j < 0 )
        return;
    
    if (i > 100 || j > 100)
        return;

    int* p = (int*)SmallAlloc(i + j);
    p[i] = 5;
}
```

## See also

[C26832](c26832.md)\
[C26833](c26833.md)