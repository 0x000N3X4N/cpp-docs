---
title: Warning C26832
description: "Describes the Microsoft C/C++ code analysis warning C26832, its causes, and how to address it."
ms.date: 03/06/2023
f1_keywords: ["C26832", "ALLOCATION_POTENTIAL_OVERFLOW_AFTER_CAST"]
helpviewer_keywords: ["C26832"]
---
# Warning C26832

> Allocation size is the result of a narrowing conversion that could result in overflow

## Remarks

Checks for allocations that have potentially overflown values as their sizes. This check is targeted to find the following code pattern:

```cpp
void* SmallAlloc(int);

void foo(unsigned short i, unsigned short j)
{
    unsigned short size = i + j;
    
    int* p = (int*)SmallAlloc(size); // Warning: C26732
    p[i] = 5;
}
```

In `i + j`, `i` and `j` will be promoted to integers and the result of the addition will be stored into a temporary integer. This integer is implicitly casted to `unsigned short` before the value is stored to `size`. The result of this cast might overflow. So, `SmallAlloc` might end up returning a buffer smaller than expected. Future accesses like `p[i]` are out of bounds. These code patterns can result in remote code execution vulnerabilities.

Our analysis engine's numerical solver have some limitations reasoning about numerical overflows. As a result, this check is using some heuristics and can sometimes be a bit noisy.

## Example

To fix the code example above, make sure `i+j` cannot overflow. For example:

```cpp
void *SmallAlloc(int);

void foo(unsigned short i, unsigned short j)
{
    if (i > 100 || j > 100)
        return;

    unsigned short size = i + j;
    
    int* p = (int*)SmallAlloc(size);
    p[i] = 5;
}
```